\section*{Problem 2: Stochastic Local Search (SLS)}

%% Uncomment the following if you need to mention formula (1):
%
% A lower bound on the number~$\lambda$ of shared elements of any pair
% among $v$~subsets of size~$r$ drawn from a given set of $b$~elements
% is given in~\cite{ASTRA:AOC}:
% \begin{equation}\label{eq:lb}
%   \text{lb}(\lambda) = 
%   \Ceiling{
%     \frac{\Ceiling{\frac{rv}{b}}^{2} ((rv) \bmod b)  +
%       \Floor{\frac{rv}{b}}^{2} (b - ((rv) \bmod b)) - rv}
%     {v(v-1)}
%   }
% \end{equation}

%%% --- COLE ISSO DENTRO DA SEÇÃO PROBLEM 2 (SLS) --- %%%

% Definições globais do Problema 2
\newcommand{\TimeoutSLS}{300.0}
\newcommand{\RunsSLS}{1}  %% Solo team

\paragraph{Task~A.}
\newcommand{\HyperOneSLS}{\alpha} 
\newcommand{\HyperTwoSLS}{\beta}
In our implementation, hyperparameters $\alpha$ and $\beta$ were unused as we relied on a dynamic Tabu tenure.

\begin{enumerate}
\item Representation.
The problem is represented by a binary matrix $M$ of size $v \times b$. Variable $m_{i,j} = 1$ if basket $i$ invests in credit $j$, and $0$ otherwise. Constraints: Each row must sum to exactly $r$. Objective: Minimize $\lambda$ (max overlap).

\item Initial Assignment.
We generate a random valid assignment by filling each row $i$ with exactly $r$ ones at random distinct positions. This guarantees the row-sum constraint is satisfied from the start.

\item Move.
We use a \textbf{1-swap move}. Select a row $i$, a column $j_{out}$ ($m_{i, j_{out}}=1$), and a column $j_{in}$ ($m_{i, j_{in}}=0$). Flip values: $1 \to 0$ at $j_{out}$, $0 \to 1$ at $j_{in}$.

\item Constraints.
The row-sum constraint ($\sum_j m_{i,j} = r$) is invariant under the swap move, so it remains satisfied throughout the search.

\item Neighbourhood.
The set of all possible 1-swaps. The size is $v \cdot r \cdot (b-r)$. The search space is connected (any valid assignment is reachable).

\item Cost Function.
The cost is the maximum pairwise intersection size $\lambda$ in the matrix. We minimize this value.

\item Probing.
We use \textbf{Delta Evaluation}. We maintain an auxiliary matrix of overlaps. When considering a move, we only update the overlaps for the modified row, reducing complexity from $O(v^2 b)$ to $O(v)$.

\item Heuristic.
We use \textbf{Stochastic Best Improvement}. We sample 200 random neighbors per iteration and pick the best one (non-tabu or aspiring).

\item Optimality.
We calculate the theoretical Lower Bound (LB). If cost equals LB, we terminate with proven optimality.

\item Meta-Heuristic.
We use \textbf{Tabu Search}. A move $(i, j_{out}, j_{in})$ is banned from being reversed for a tenure of 10 iterations.

\item Random Restarts.
Not implemented (Tabu was sufficient).

\item Optional Tweaks.
Efficient incremental updates (Delta Update) for the overlap matrix.
\end{enumerate}

\paragraph{Task~B.}
We chose \textbf{Java}. Source code is uploaded. Compilation: \texttt{javac invDes/*.java}. Running: \texttt{java InvDes v b r}. We validated correctness using the provided solution checker.

\paragraph{Task~C.}
All experiments were run under macOS (emulating Linux environment via JVM).
The results are in Table~\ref{tab:res:sls}.

%% Optional for solo teams:
\paragraph{Task~D.}
An exact algorithm would require checking all combinations of columns per row, with a search space size roughly proportional to $\binom{b}{r}^v$. The complexity grows factorially, making it infeasible for large $v, b$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "assignment1-report"
%%% End:
